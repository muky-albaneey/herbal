import{a as H}from"./react-CWdn-sfl.js";import{u as O}from"./use-sync-external-store-BmewEb-I.js";import{p as P}from"./immer-CwDZyRGJ.js";const z={BASE_URL:"/",DEV:!1,MODE:"production",PROD:!0,SSR:!1},E=e=>{let i;const s=new Set,n=(S,y)=>{const v=typeof S=="function"?S(i):S;if(!Object.is(v,i)){const g=i;i=y??(typeof v!="object"||v===null)?v:Object.assign({},i,v),s.forEach(p=>p(i,g))}},a=()=>i,f={setState:n,getState:a,getInitialState:()=>l,subscribe:S=>(s.add(S),()=>s.delete(S)),destroy:()=>{(z?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),s.clear()}},l=i=e(n,a,f);return f},A=e=>e?E(e):E,R={BASE_URL:"/",DEV:!1,MODE:"production",PROD:!0,SSR:!1},{useDebugValue:F}=H,{useSyncExternalStoreWithSelector:L}=O;let b=!1;const T=e=>e;function U(e,i=T,s){(R?"production":void 0)!=="production"&&s&&!b&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),b=!0);const n=L(e.subscribe,e.getState,e.getServerState||e.getInitialState,i,s);return F(n),n}const I=e=>{(R?"production":void 0)!=="production"&&typeof e!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const i=typeof e=="function"?A(e):e,s=(n,a)=>U(i,n,a);return Object.assign(s,i),s},M=e=>e?I(e):I,x=e=>(i,s,n)=>(n.setState=(a,t,...m)=>{const d=typeof a=="function"?P(a):a;return i(d,t,...m)},e(n.setState,s,n)),q=x,C={BASE_URL:"/",DEV:!1,MODE:"production",PROD:!0,SSR:!1};function j(e,i){let s;try{s=e()}catch{return}return{getItem:a=>{var t;const m=f=>f===null?null:JSON.parse(f,void 0),d=(t=s.getItem(a))!=null?t:null;return d instanceof Promise?d.then(m):m(d)},setItem:(a,t)=>s.setItem(a,JSON.stringify(t,void 0)),removeItem:a=>s.removeItem(a)}}const _=e=>i=>{try{const s=e(i);return s instanceof Promise?s:{then(n){return _(n)(s)},catch(n){return this}}}catch(s){return{then(n){return this},catch(n){return _(n)(s)}}}},J=(e,i)=>(s,n,a)=>{let t={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:o=>o,version:0,merge:(o,u)=>({...u,...o}),...i},m=!1;const d=new Set,f=new Set;let l;try{l=t.getStorage()}catch{}if(!l)return e((...o)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),s(...o)},n,a);const S=_(t.serialize),y=()=>{const o=t.partialize({...n()});let u;const r=S({state:o,version:t.version}).then(h=>l.setItem(t.name,h)).catch(h=>{u=h});if(u)throw u;return r},v=a.setState;a.setState=(o,u)=>{v(o,u),y()};const g=e((...o)=>{s(...o),y()},n,a);let p;const c=()=>{var o;if(!l)return;m=!1,d.forEach(r=>r(n()));const u=((o=t.onRehydrateStorage)==null?void 0:o.call(t,n()))||void 0;return _(l.getItem.bind(l))(t.name).then(r=>{if(r)return t.deserialize(r)}).then(r=>{if(r)if(typeof r.version=="number"&&r.version!==t.version){if(t.migrate)return t.migrate(r.state,r.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return r.state}).then(r=>{var h;return p=t.merge(r,(h=n())!=null?h:g),s(p,!0),y()}).then(()=>{u==null||u(p,void 0),m=!0,f.forEach(r=>r(p))}).catch(r=>{u==null||u(void 0,r)})};return a.persist={setOptions:o=>{t={...t,...o},o.getStorage&&(l=o.getStorage())},clearStorage:()=>{l==null||l.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>c(),hasHydrated:()=>m,onHydrate:o=>(d.add(o),()=>{d.delete(o)}),onFinishHydration:o=>(f.add(o),()=>{f.delete(o)})},c(),p||g},N=(e,i)=>(s,n,a)=>{let t={storage:j(()=>localStorage),partialize:c=>c,version:0,merge:(c,o)=>({...o,...c}),...i},m=!1;const d=new Set,f=new Set;let l=t.storage;if(!l)return e((...c)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),s(...c)},n,a);const S=()=>{const c=t.partialize({...n()});return l.setItem(t.name,{state:c,version:t.version})},y=a.setState;a.setState=(c,o)=>{y(c,o),S()};const v=e((...c)=>{s(...c),S()},n,a);a.getInitialState=()=>v;let g;const p=()=>{var c,o;if(!l)return;m=!1,d.forEach(r=>{var h;return r((h=n())!=null?h:v)});const u=((o=t.onRehydrateStorage)==null?void 0:o.call(t,(c=n())!=null?c:v))||void 0;return _(l.getItem.bind(l))(t.name).then(r=>{if(r)if(typeof r.version=="number"&&r.version!==t.version){if(t.migrate)return[!0,t.migrate(r.state,r.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,r.state];return[!1,void 0]}).then(r=>{var h;const[D,w]=r;if(g=t.merge(w,(h=n())!=null?h:v),s(g,!0),D)return S()}).then(()=>{u==null||u(g,void 0),g=n(),m=!0,f.forEach(r=>r(g))}).catch(r=>{u==null||u(void 0,r)})};return a.persist={setOptions:c=>{t={...t,...c},c.storage&&(l=c.storage)},clearStorage:()=>{l==null||l.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>p(),hasHydrated:()=>m,onHydrate:c=>(d.add(c),()=>{d.delete(c)}),onFinishHydration:c=>(f.add(c),()=>{f.delete(c)})},t.skipHydration||p(),g||v},B=(e,i)=>"getStorage"in i||"serialize"in i||"deserialize"in i?((C?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),J(e,i)):N(e,i),G=B;export{j as a,M as c,q as i,G as p};
